#include "framework.h"

Control::Control()
	: cur_state{}, old_state{}, map_state{}
	// 배열 역시 타겟 생성자로 초기화하는 것이 가능
{
}

Control::~Control()
{
}

void Control::Update()
{
	memcpy(old_state, cur_state, sizeof(old_state));
	// 왼쪽 포인터에 오른쪽 포인터가 가지고 있는 값들을 복사하는 함수
	// 복사하는 범위는 old_state가 가지고 있는 용량만큼
	// = 업데이트 시점에서 기존 상태를 갱신

	GetKeyboardState(cur_state);
	// BYTE[256] 배열에 현 시점의 키보드에 있는 키 중 어느 키가 눌렸는지를 전부 기록하는 함수
	// 이 함수를 통해 현 시점 입력장치들의 키 입력 현황을 cur_state에 저장

	// 시스템에서 키가 어떻게 저장되어 있는지 설명하자면,
	// 0과 1으로 저장할 것 같다고 예상하기 쉽지만
	// 실제로는 해당 키가 눌려있을 경우 128 || 129,
	// 눌려있지 않다면 0 || 1이라는 값을 가지게 됨
	// 시스템상 각 키가 눌릴 때마다 해당 키가 눌렸는지를 표현하는 값이
	// 128(눌림) -> 0(눌리지 않음) -> 129(눌림) -> 1(눌리지 않음)의 순서대로
	// 대응하는 값이 변동하면서 순환되는 것으로 눌림/안눌림을 체크하고 있음

	// 이는 더블클릭 등의 기능을 쉽게 구현하기 위해 만들어진 구성

	for (int i = 0; i < KEY_MAX; i++)
	// 여기서 사용되는 이 i값은 가상 키 코드의 역할을 함
	// -> 저 배열들에 들어가는 인덱스들은 그 인덱스와 같은 값의 가상 키 코드에 대응되는 각 키
	// 이를 통해 실제 키보드의 키 중 어떤 것을 다루는 것인지를 명시
	{
		// 입력받은 모든 키들을 점검하는 동시에,
		// 최종적으로 각 키의 현재 상태를 검사하는 타이밍

		BYTE key = cur_state[i] & 0x80;
		// 0x80 = 128, 시스템에서 해당 키가 눌려있을 경우 반드시 할당되는 비트
		// 그 비트와 AND 비트 연산을 하는 것으로, 잡다한 키는 무시하고
		// 해당 키가 눌려있는지 아닌지만 판단할 수 있게 됨

		cur_state[i] = key ? 1 : 0;
		// 키가 눌려있다면 cur_state의 현 인덱스의 값은 128 || 129
		// 이를 16진수로 표기하면 0x80 || 0x81
		// 1의 비트 쪽은 우리가 제어할 수단이 없으니 AND 비트 연산을 통해 쳐낸 뒤,
		// 남은 값이 0인지 아닌지 = 비트가 남아있는지 아닌지를 검사하여
		// 비트가 남아있으면 "눌렸다", 비트가 남아있지 않다면 "눌리지 않았다"라고 저장


		BYTE old = old_state[i];
		BYTE cur = cur_state[i];
		// 현재 검사하고자 하는 키가 직전에 눌렸는지 + 현재 눌려있는지 각각을
		// 그 각각이 저장되어 있던 배열에서 가져옴
		// 1바이트짜리 변수이므로,
		// 기존 걸 재활용하지 않고 가독성을 위해 새로 만들어도 별 문제 X

		// 그 둘의 키가 어떤 배치인지를 검사하여 최종적인 해당 키의 현 상태를 확정
		if (old == 0 && cur == 1) // 좀전까지 안 눌려있던 키가 지금 눌렸다 : DOWN
		{
			map_state[i] = DOWN;
		}
		else if(old == 1 && cur == 0) // 좀전까지 눌려있던 키가 지금 떼졌다 : UP
		{
			map_state[i] = UP;
		}
		else if (old == 1 && cur == 1) // 직전에도 지금도 눌려있다 : PRESS
		{
			map_state[i] = PRESS;
		}
		else // 다 아니다 = 애초에 눌려있지 않았다 : NONE
		{
			map_state[i] = NONE;
		}
	}

}
